<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Edge Case Simulator - LEGO Loader</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
    canvas { display: block; }

    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 12px 16px;
      pointer-events: none;
      z-index: 10;
    }

    .hud-left, .hud-right { display: flex; gap: 8px; align-items: flex-start; }

    .hud-box {
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 8px 14px;
      color: #fff;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .hud-box .label { opacity: 0.7; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }
    .hud-box .value { font-weight: 700; font-size: 18px; }

    #state-box .value { color: #ff6b6b; font-size: 14px; }
    #legos-box .value { color: #4ecdc4; }
    #collected-box .value { color: #ffd700; }

    /* Scenario Metadata HUD - top center */
    #scenario-hud {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 8px 20px;
      color: #fff;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 11;
      pointer-events: none;
      white-space: nowrap;
    }

    #scenario-hud .scenario-id {
      font-weight: 800;
      font-size: 15px;
      color: #4ecdc4;
      font-family: 'Courier New', monospace;
    }

    #scenario-hud .scenario-name {
      font-weight: 600;
      font-size: 13px;
    }

    #scenario-hud .tier-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 8px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .tier-badge.tier-1 { background: #27ae60; color: #fff; }
    .tier-badge.tier-2 { background: #f39c12; color: #fff; }
    .tier-badge.tier-3 { background: #e74c3c; color: #fff; }

    #scenario-hud .sps-value {
      font-weight: 700;
      color: #ffd700;
      font-size: 13px;
    }

    #action-display {
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      padding: 10px 14px;
      color: #fff;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      z-index: 10;
      pointer-events: none;
      line-height: 1.6;
    }

    #recording-indicator {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 20, 20, 0.85);
      border-radius: 20px;
      padding: 6px 16px;
      color: #fff;
      font-size: 13px;
      font-weight: 700;
      z-index: 10;
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #recording-indicator .dot {
      width: 10px; height: 10px;
      background: #fff;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    #complete-screen {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(20px);
      z-index: 100;
      color: #fff;
    }

    #complete-screen .title {
      font-size: 42px;
      font-weight: 900;
      background: linear-gradient(135deg, #ffd700, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 16px;
    }

    #complete-screen .stats {
      font-size: 18px;
      opacity: 0.8;
      margin-bottom: 24px;
      text-align: center;
      line-height: 2;
    }

    #download-btn {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 700;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      background: linear-gradient(135deg, #4ecdc4, #44d97c);
      color: #fff;
      box-shadow: 0 4px 20px rgba(78, 205, 196, 0.4);
      transition: transform 0.2s;
    }

    #download-btn:hover { transform: scale(1.05); }

    .miniview {
      position: fixed;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      overflow: hidden;
      z-index: 5;
      pointer-events: none;
      right: 12px;
      width: 200px;
      height: 140px;
    }

    #miniview-ego   { top: 60px; }
    #miniview-bird  { top: 210px; }
    #miniview-side  { top: 360px; }
    #miniview-front { top: 510px; }

    .miniview-label {
      position: absolute;
      bottom: 4px;
      left: 8px;
      color: rgba(255,255,255,0.7);
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

  <!-- HUD -->
  <div id="hud">
    <div class="hud-left">
      <div class="hud-box" id="state-box">
        <span class="label">Agent State</span>
        <span class="value" id="agent-state">SCANNING</span>
      </div>
      <div class="hud-box" id="legos-box">
        <span class="label">Remaining</span>
        <span class="value" id="legos-remaining">0</span>
      </div>
      <div class="hud-box" id="collected-box">
        <span class="label">Collected</span>
        <span class="value" id="legos-collected">0</span>
      </div>
    </div>
    <div class="hud-right">
      <div class="hud-box">
        <span class="label">Frame</span>
        <span class="value" id="frame-count">0</span>
      </div>
    </div>
  </div>

  <!-- Scenario Metadata HUD -->
  <div id="scenario-hud">
    <span class="scenario-id" id="hud-scenario-id">DEFAULT</span>
    <span class="scenario-name" id="hud-scenario-name">Standard Configuration</span>
    <span class="tier-badge tier-1" id="hud-tier-badge">TIER 1</span>
    <span class="sps-value" id="hud-sps">SPS: --</span>
  </div>

  <div id="recording-indicator">
    <div class="dot"></div>
    <span>REC</span>
  </div>

  <div id="action-display">
    steering: 0.00<br>
    throttle: 0.00<br>
    bucket: 0.00<br>
    lift: 0.00
  </div>

  <!-- Mini views (4 sub-cameras) -->
  <div class="miniview" id="miniview-ego">
    <canvas id="canvas-ego" width="200" height="140"></canvas>
    <div class="miniview-label">EGO (1ST PERSON)</div>
  </div>
  <div class="miniview" id="miniview-bird">
    <canvas id="canvas-bird" width="200" height="140"></canvas>
    <div class="miniview-label">BIRD'S EYE</div>
  </div>
  <div class="miniview" id="miniview-side">
    <canvas id="canvas-side" width="200" height="140"></canvas>
    <div class="miniview-label">SIDE VIEW</div>
  </div>
  <div class="miniview" id="miniview-front">
    <canvas id="canvas-front" width="200" height="140"></canvas>
    <div class="miniview-label">FRONT ANGLE</div>
  </div>

  <!-- Complete Screen -->
  <div id="complete-screen">
    <div class="title">CLEANUP COMPLETE!</div>
    <div class="stats" id="complete-stats"></div>
    <button id="download-btn" style="display:none;">Download Video</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { getScenario, SCENARIOS, CATEGORIES } from './scenarios.js';

    // ====== URL PARAMS ======
    const urlParams = new URLSearchParams(window.location.search);
    const scenarioId = urlParams.get('scenario');
    const autoRecord = urlParams.get('autoRecord') === 'true';

    // ====== DEFAULT CONFIG ======
    const DEFAULT_CONFIG = {
      id: 'DEFAULT',
      name: 'Standard Configuration',
      nameEn: 'Standard Configuration',
      category: null,
      tier: 1,
      sps: null,
      room: { size: 16, floorColor: 0xDEB887, floorRoughness: 0.8, floorMetalness: 0.0 },
      lighting: { ambientIntensity: 0.5, directionalIntensity: 1.8, directionalPosition: [8, 15, 10], shadowIntensity: 0.5, toneMappingExposure: 1.2 },
      legos: { count: 20, colors: null, distribution: 'random', types: {} },
      loader: { startPosition: [4, 0, 4] },
      box: { position: [-6, 0, -6], size: 'normal' },
      furniture: { density: 'normal', extras: [] },
      dynamic: {},
      // Optional edge-case fields (all default to absent/undefined)
      floorSlope: null,
      distractors: null,
      obstacles: null,
      forbiddenObjects: null,
      bucketVibration: null,
      sensorNoise: null,
      ghostTargetDelay: null,
      stuckLegoRatio: null,
      stuckScoopExtraTime: null,
    };

    // ====== MERGE CONFIG ======
    function deepMerge(target, source) {
      const result = { ...target };
      for (const key of Object.keys(source)) {
        if (source[key] !== undefined && source[key] !== null) {
          if (typeof source[key] === 'object' && !Array.isArray(source[key]) && typeof target[key] === 'object' && !Array.isArray(target[key]) && target[key] !== null) {
            result[key] = deepMerge(target[key], source[key]);
          } else {
            result[key] = source[key];
          }
        }
      }
      return result;
    }

    const loadedScenario = scenarioId ? getScenario(scenarioId) : null;
    const SCENARIO_CONFIG = loadedScenario ? deepMerge(DEFAULT_CONFIG, loadedScenario) : { ...DEFAULT_CONFIG };

    // ====== DERIVED CONSTANTS FROM CONFIG ======
    const LEGO_COUNT = SCENARIO_CONFIG.legos.count;
    const ROOM_SIZE = SCENARIO_CONFIG.room.size;
    const BOX_POS = new THREE.Vector3(
      SCENARIO_CONFIG.box.position[0],
      SCENARIO_CONFIG.box.position[1],
      SCENARIO_CONFIG.box.position[2]
    );
    const LOADER_START = new THREE.Vector3(
      SCENARIO_CONFIG.loader.startPosition[0],
      SCENARIO_CONFIG.loader.startPosition[1],
      SCENARIO_CONFIG.loader.startPosition[2]
    );
    const SIM_DT = 1 / 30;

    // ====== LEGO COLORS ======
    const DEFAULT_LEGO_COLORS = [
      0xDA291C, 0x006DB7, 0xFED700, 0x00963E, 0xFF6D00,
      0xE4E4E4, 0x9C27B0, 0x00BCD4, 0xF06292, 0x8D6E63,
    ];

    const LEGO_COLORS = SCENARIO_CONFIG.legos.colors || DEFAULT_LEGO_COLORS;

    // ====== BRICK TYPES (with 8x2 added for xlarge) ======
    const DEFAULT_BRICK_TYPES = [
      { x: 4, z: 2 }, { x: 2, z: 2 }, { x: 3, z: 2 },
      { x: 6, z: 2 }, { x: 1, z: 1 }, { x: 2, z: 1 },
      { x: 4, z: 1 }, { x: 1, z: 2 },
    ];

    const XLARGE_BRICK_TYPES = [
      { x: 6, z: 4 }, { x: 8, z: 2 },
    ];

    const TINY_BRICK_TYPES = [
      { x: 1, z: 1 },
    ];

    // Select brick types based on config
    function getActiveBrickTypes() {
      const typeConfig = SCENARIO_CONFIG.legos.types || {};
      if (typeConfig.tiny && typeConfig.tiny > 0) {
        return TINY_BRICK_TYPES;
      }
      if (typeConfig.xlarge && typeConfig.xlarge > 0) {
        return XLARGE_BRICK_TYPES;
      }
      return DEFAULT_BRICK_TYPES;
    }

    const BRICK_TYPES = getActiveBrickTypes();

    const UNIT = 0.8;
    const BRICK_H = 0.96;
    const STUD_R = 0.24;
    const STUD_H = 0.17;

    // ====== SCENARIO HUD UPDATE ======
    (function updateScenarioHUD() {
      const idEl = document.getElementById('hud-scenario-id');
      const nameEl = document.getElementById('hud-scenario-name');
      const tierEl = document.getElementById('hud-tier-badge');
      const spsEl = document.getElementById('hud-sps');

      idEl.textContent = SCENARIO_CONFIG.id;
      nameEl.textContent = SCENARIO_CONFIG.nameEn || SCENARIO_CONFIG.name || 'Standard Configuration';

      const tier = SCENARIO_CONFIG.tier || 1;
      tierEl.textContent = `TIER ${tier}`;
      tierEl.className = `tier-badge tier-${tier}`;

      if (SCENARIO_CONFIG.sps != null) {
        spsEl.textContent = `SPS: ${SCENARIO_CONFIG.sps.toFixed(1)}`;
      } else {
        spsEl.textContent = 'SPS: --';
      }

      // Apply category color to scenario ID if applicable
      if (SCENARIO_CONFIG.category && CATEGORIES[SCENARIO_CONFIG.category]) {
        idEl.style.color = CATEGORIES[SCENARIO_CONFIG.category].color;
      }
    })();

    // ====== RENDERER (main follow view) ======
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1); // fixed for recording
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = SCENARIO_CONFIG.lighting.toneMappingExposure || 1.2;
    document.body.prepend(renderer.domElement);

    // ====== Mini renderers (4 sub-views) ======
    const MINI_W = 200, MINI_H = 140;

    function makeMiniRenderer(canvasId) {
      const c = document.getElementById(canvasId);
      const r = new THREE.WebGLRenderer({ canvas: c, antialias: false });
      r.setSize(MINI_W, MINI_H);
      r.shadowMap.enabled = false;
      r.toneMapping = THREE.ACESFilmicToneMapping;
      r.toneMappingExposure = SCENARIO_CONFIG.lighting.toneMappingExposure || 1.2;
      return r;
    }

    const egoRenderer = makeMiniRenderer('canvas-ego');
    const birdRenderer = makeMiniRenderer('canvas-bird');
    const sideRenderer = makeMiniRenderer('canvas-side');
    const frontRenderer = makeMiniRenderer('canvas-front');

    // ====== SCENE ======
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 25, 40);

    // ====== CAMERAS ======
    const followCam = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    followCam.position.set(LOADER_START.x + 6, 8, LOADER_START.z + 8);
    followCam.lookAt(LOADER_START);

    const egoCam = new THREE.PerspectiveCamera(70, MINI_W / MINI_H, 0.1, 100);

    const birdCam = new THREE.PerspectiveCamera(60, MINI_W / MINI_H, 0.1, 100);
    birdCam.position.set(0, 14, 0);
    birdCam.up.set(0, 0, -1);
    birdCam.lookAt(0, 0, 0);

    const sideCam = new THREE.PerspectiveCamera(50, MINI_W / MINI_H, 0.1, 100);
    const frontCam = new THREE.PerspectiveCamera(55, MINI_W / MINI_H, 0.1, 100);

    // ====== LIGHTING (from config) ======
    const ambientLight = new THREE.AmbientLight(0xffffff, SCENARIO_CONFIG.lighting.ambientIntensity);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff5e0, SCENARIO_CONFIG.lighting.directionalIntensity);
    const dlPos = SCENARIO_CONFIG.lighting.directionalPosition;
    sunLight.position.set(dlPos[0], dlPos[1], dlPos[2]);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 40;
    sunLight.shadow.camera.left = -12;
    sunLight.shadow.camera.right = 12;
    sunLight.shadow.camera.top = 12;
    sunLight.shadow.camera.bottom = -12;
    sunLight.shadow.bias = -0.001;
    scene.add(sunLight);

    scene.add(new THREE.DirectionalLight(0x8ecae6, 0.4).translateX(-5).translateY(8).translateZ(-5));

    // ====== ROOM (parameterized) ======
    // Track extra furniture leg positions for under_furniture distribution
    const furnitureLegPositions = [];

    function createRoom() {
      const roomGroup = new THREE.Group();
      const roomCfg = SCENARIO_CONFIG.room;
      const halfRoom = ROOM_SIZE / 2;

      // Floor
      const floorGeo = new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE);
      const floorMat = new THREE.MeshStandardMaterial({
        color: roomCfg.floorColor,
        roughness: roomCfg.floorRoughness,
        metalness: roomCfg.floorMetalness || 0.0,
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;

      // Apply floor slope if configured (FM-A04)
      if (SCENARIO_CONFIG.floorSlope) {
        const slopeAngle = (SCENARIO_CONFIG.floorSlope.angle || 0) * Math.PI / 180;
        const axis = SCENARIO_CONFIG.floorSlope.axis || 'z';
        if (axis === 'z') {
          floor.rotation.z = slopeAngle;
        } else if (axis === 'x') {
          // Rotate around local x relative to the already-rotated plane
          floor.rotation.z = slopeAngle;
        }
      }

      roomGroup.add(floor);

      // Floor planks
      const plankRange = Math.floor(halfRoom) - 1;
      for (let i = -plankRange; i <= plankRange; i++) {
        const line = new THREE.Mesh(
          new THREE.PlaneGeometry(0.02, ROOM_SIZE),
          new THREE.MeshStandardMaterial({ color: 0xC8A882, roughness: 0.9 })
        );
        line.rotation.x = -Math.PI / 2;
        line.position.set(i, 0.001, 0);
        roomGroup.add(line);
      }

      // Boundary markers
      const edgeMat = new THREE.MeshStandardMaterial({ color: 0xBBBBBB, roughness: 0.8 });
      [[-halfRoom, 0], [0, -halfRoom]].forEach(([x, z]) => {
        const isX = z === -halfRoom;
        const edge = new THREE.Mesh(
          new THREE.BoxGeometry(isX ? ROOM_SIZE : 0.05, 0.02, isX ? 0.05 : ROOM_SIZE),
          edgeMat
        );
        edge.position.set(x === -halfRoom ? -halfRoom : 0, 0.01, z === -halfRoom ? -halfRoom : 0);
        roomGroup.add(edge);
      });

      // Storage box (size from config)
      const boxGroup = new THREE.Group();
      const boxMat = new THREE.MeshStandardMaterial({ color: 0x4A90D9, roughness: 0.3 });
      const isSmallBox = SCENARIO_CONFIG.box.size === 'small';
      const boxW = isSmallBox ? 1.5 : 2.5;
      const boxD = isSmallBox ? 1.2 : 2;
      const boxH = isSmallBox ? 0.6 : 1;

      const boxBottom = new THREE.Mesh(new THREE.BoxGeometry(boxW, 0.1, boxD), boxMat);
      boxBottom.position.y = 0.05;
      boxBottom.castShadow = true;
      boxGroup.add(boxBottom);

      const sideGeo = new THREE.BoxGeometry(boxW, boxH, 0.1);
      [[0, boxH / 2, boxD / 2], [0, boxH / 2, -boxD / 2]].forEach(([x, y, z]) => {
        const s = new THREE.Mesh(sideGeo, boxMat);
        s.position.set(x, y, z);
        s.castShadow = true;
        boxGroup.add(s);
      });
      const sideGeo2 = new THREE.BoxGeometry(0.1, boxH, boxD);
      [[-boxW / 2, boxH / 2, 0], [boxW / 2, boxH / 2, 0]].forEach(([x, y, z]) => {
        const s = new THREE.Mesh(sideGeo2, boxMat);
        s.position.set(x, y, z);
        s.castShadow = true;
        boxGroup.add(s);
      });
      boxGroup.position.set(BOX_POS.x, BOX_POS.y, BOX_POS.z);
      roomGroup.add(boxGroup);

      // Rug
      const rug = new THREE.Mesh(
        new THREE.CircleGeometry(3.5, 32),
        new THREE.MeshStandardMaterial({ color: 0xD4B896, roughness: 0.95 })
      );
      rug.rotation.x = -Math.PI / 2;
      rug.position.set(1, 0.005, 1);
      roomGroup.add(rug);

      // Default table
      const tableMat = new THREE.MeshStandardMaterial({ color: 0xA0855B, roughness: 0.6 });
      const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.08, 1.8), tableMat);
      tableTop.position.set(5.5, 1.2, -6.5);
      tableTop.castShadow = true;
      roomGroup.add(tableTop);
      const legGeo = new THREE.CylinderGeometry(0.06, 0.06, 1.2, 8);
      [[-1, -0.7], [1, -0.7], [-1, 0.7], [1, 0.7]].forEach(([lx, lz]) => {
        const leg = new THREE.Mesh(legGeo, tableMat);
        leg.position.set(5.5 + lx, 0.6, -6.5 + lz);
        roomGroup.add(leg);
        furnitureLegPositions.push(new THREE.Vector3(5.5 + lx, 0, -6.5 + lz));
      });

      // Teddy bear
      const bearMat = new THREE.MeshStandardMaterial({ color: 0xD2A679, roughness: 0.9 });
      const bearBody = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), bearMat);
      bearBody.position.set(6, 0.25, 3);
      bearBody.scale.y = 1.2;
      roomGroup.add(bearBody);
      const bearHead = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), bearMat);
      bearHead.position.set(6, 0.6, 3);
      roomGroup.add(bearHead);

      scene.add(roomGroup);
    }

    // ====== EXTRA FURNITURE (from config) ======
    function createExtraFurniture(extras) {
      if (!extras || extras.length === 0) return;

      extras.forEach(item => {
        const [px, py, pz] = item.position;
        const [sx, sy, sz] = item.size;

        if (item.type === 'table') {
          const mat = new THREE.MeshStandardMaterial({ color: 0xA0855B, roughness: 0.6 });
          // Table top
          const top = new THREE.Mesh(new THREE.BoxGeometry(sx, 0.08, sz), mat);
          top.position.set(px, sy, pz);
          top.castShadow = true;
          scene.add(top);

          // 4 legs
          const legH = sy;
          const legGeo = new THREE.CylinderGeometry(0.06, 0.06, legH, 8);
          const halfX = (sx / 2) - 0.1;
          const halfZ = (sz / 2) - 0.1;
          [[-halfX, -halfZ], [halfX, -halfZ], [-halfX, halfZ], [halfX, halfZ]].forEach(([lx, lz]) => {
            const leg = new THREE.Mesh(legGeo, mat);
            leg.position.set(px + lx, legH / 2, pz + lz);
            scene.add(leg);
            furnitureLegPositions.push(new THREE.Vector3(px + lx, 0, pz + lz));
          });
        } else if (item.type === 'shelf') {
          const mat = new THREE.MeshStandardMaterial({ color: 0x8B6F47, roughness: 0.7 });
          const shelf = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), mat);
          shelf.position.set(px, sy / 2, pz);
          shelf.castShadow = true;
          shelf.receiveShadow = true;
          scene.add(shelf);
        }
      });
    }

    // ====== OBSTACLES (from config, FM-C03, FM-D04) ======
    function createObstacles(obstacles) {
      if (!obstacles || obstacles.length === 0) return;

      obstacles.forEach(obs => {
        const [px, py, pz] = obs.position;
        const [sx, sy, sz] = obs.size;
        const color = obs.type === 'cardboard' ? 0xC4A97D :
                      obs.type === 'shoes' ? 0x5D4037 :
                      0xBFA882; // default brown/beige
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.8 });
        const box = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), mat);
        box.position.set(px, sy / 2, pz);
        box.castShadow = true;
        box.receiveShadow = true;
        scene.add(box);
      });
    }

    // ====== DISTRACTORS (FM-A07) ======
    function createDistractors(config) {
      if (!config) return;

      const count = config.count || 10;
      const types = config.types || ['sphere', 'cylinder', 'coin'];
      const halfRoom = ROOM_SIZE / 2;
      const distractorColors = [
        0xCC2222, 0x2266BB, 0xEEC800, 0x008833, 0xDD5500,
        0xCCCCCC, 0x882299, 0x009999, 0xDD5588, 0x776655,
      ];

      for (let i = 0; i < count; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const color = distractorColors[Math.floor(Math.random() * distractorColors.length)];
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
        let mesh;

        switch (type) {
          case 'sphere':
            mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15 + Math.random() * 0.15, 12, 12), mat);
            break;
          case 'cylinder':
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.3 + Math.random() * 0.3, 12), mat);
            break;
          case 'coin':
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.03, 16), mat);
            break;
          case 'battery':
            mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8), mat);
            break;
          default:
            mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.2), mat);
        }

        let px, pz;
        do {
          px = (Math.random() - 0.5) * (ROOM_SIZE - 2);
          pz = (Math.random() - 0.5) * (ROOM_SIZE - 2);
        } while (px < BOX_POS.x + 2 && px > BOX_POS.x - 2 && pz < BOX_POS.z + 2 && pz > BOX_POS.z - 2);

        mesh.position.set(px, 0.15, pz);
        mesh.rotation.y = Math.random() * Math.PI * 2;
        mesh.castShadow = true;
        scene.add(mesh);
      }
    }

    // ====== FORBIDDEN OBJECTS (FM-B05) ======
    function createForbiddenObjects(objects) {
      if (!objects || objects.length === 0) return;

      objects.forEach(obj => {
        const [px, py, pz] = obj.position;
        const safetyR = obj.safetyRadius || 0.5;

        let mesh;
        if (obj.type === 'glass') {
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0xAADDFF, roughness: 0.05, metalness: 0.1,
            transparent: true, opacity: 0.4,
          });
          mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, 0.25, 12), glassMat);
          mesh.position.set(px, 0.125, pz);
        } else if (obj.type === 'vase') {
          const vaseMat = new THREE.MeshStandardMaterial({
            color: 0xFFCCDD, roughness: 0.1, metalness: 0.0,
            transparent: true, opacity: 0.5,
          });
          mesh = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), vaseMat);
          mesh.position.set(px, 0.15, pz);
          mesh.scale.set(1, 1.5, 1);
        } else {
          // electronics or generic
          const elMat = new THREE.MeshStandardMaterial({
            color: 0x333333, roughness: 0.3, metalness: 0.5,
          });
          mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.05, 0.12), elMat);
          mesh.position.set(px, 0.025, pz);
        }
        mesh.castShadow = true;
        scene.add(mesh);

        // Warning ring
        const ringGeo = new THREE.RingGeometry(safetyR - 0.02, safetyR + 0.02, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xFF0000, side: THREE.DoubleSide, transparent: true, opacity: 0.35 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.set(px, 0.005, pz);
        scene.add(ring);
      });
    }

    // ====== LEGO BRICKS ======
    const bricks = [];
    const studGeo = new THREE.CylinderGeometry(STUD_R, STUD_R, STUD_H, 8);

    function createLegoBrick(studsX, studsZ, color) {
      const group = new THREE.Group();
      group.userData.color = color;
      group.userData.collected = false;
      group.userData.stuck = false;

      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.25 });
      const bodyW = studsX * UNIT;
      const bodyD = studsZ * UNIT;
      const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, BRICK_H, bodyD), mat);
      body.position.y = BRICK_H / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);

      for (let sx = 0; sx < studsX; sx++) {
        for (let sz = 0; sz < studsZ; sz++) {
          const stud = new THREE.Mesh(studGeo, mat);
          stud.position.set(
            (sx - (studsX - 1) / 2) * UNIT,
            BRICK_H + STUD_H / 2,
            (sz - (studsZ - 1) / 2) * UNIT
          );
          group.add(stud);
        }
      }
      return group;
    }

    // ====== LEGO PLACEMENT STRATEGIES ======
    function scatterBricks(count) {
      const distribution = SCENARIO_CONFIG.legos.distribution || 'random';
      const halfRoom = ROOM_SIZE / 2;
      const margin = halfRoom - 0.5;
      const stuckRatio = SCENARIO_CONFIG.stuckLegoRatio || 0;

      for (let i = 0; i < count; i++) {
        const type = BRICK_TYPES[Math.floor(Math.random() * BRICK_TYPES.length)];
        const color = LEGO_COLORS[Math.floor(Math.random() * LEGO_COLORS.length)];
        const brick = createLegoBrick(type.x, type.z, color);

        let px, pz;

        switch (distribution) {
          case 'wall_adjacent': {
            const wallRatio = SCENARIO_CONFIG.legos.wallRatio || 0.4;
            if (Math.random() < wallRatio) {
              // Place near room edges (within 1.5 units of edge)
              const edge = Math.floor(Math.random() * 4);
              switch (edge) {
                case 0: px = -margin + Math.random() * 1.5; pz = (Math.random() - 0.5) * (ROOM_SIZE - 2); break;
                case 1: px = margin - Math.random() * 1.5; pz = (Math.random() - 0.5) * (ROOM_SIZE - 2); break;
                case 2: pz = -margin + Math.random() * 1.5; px = (Math.random() - 0.5) * (ROOM_SIZE - 2); break;
                case 3: pz = margin - Math.random() * 1.5; px = (Math.random() - 0.5) * (ROOM_SIZE - 2); break;
              }
            } else {
              do {
                px = (Math.random() - 0.5) * (ROOM_SIZE - 4);
                pz = (Math.random() - 0.5) * (ROOM_SIZE - 4);
              } while (Math.abs(px - BOX_POS.x) < 2 && Math.abs(pz - BOX_POS.z) < 2);
            }
            break;
          }
          case 'clustered': {
            const clusterCount = SCENARIO_CONFIG.legos.clusterCount || 3;
            // Generate cluster centers on first call (store on config)
            if (!SCENARIO_CONFIG._clusterCenters) {
              SCENARIO_CONFIG._clusterCenters = [];
              for (let c = 0; c < clusterCount; c++) {
                SCENARIO_CONFIG._clusterCenters.push({
                  x: (Math.random() - 0.5) * (ROOM_SIZE - 6),
                  z: (Math.random() - 0.5) * (ROOM_SIZE - 6),
                });
              }
            }
            const center = SCENARIO_CONFIG._clusterCenters[i % clusterCount];
            const radius = 2 + Math.random() * 1; // 2-3 unit radius
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * radius;
            px = center.x + Math.cos(angle) * r;
            pz = center.z + Math.sin(angle) * r;
            // Clamp
            px = Math.max(-margin, Math.min(margin, px));
            pz = Math.max(-margin, Math.min(margin, pz));
            break;
          }
          case 'extreme_spread': {
            // Force legos to corners and edges
            const zone = Math.floor(Math.random() * 8); // 4 corners + 4 edges
            const cornerDist = margin - 1;
            switch (zone) {
              case 0: px = -cornerDist + Math.random(); pz = -cornerDist + Math.random(); break;
              case 1: px = cornerDist - Math.random(); pz = -cornerDist + Math.random(); break;
              case 2: px = -cornerDist + Math.random(); pz = cornerDist - Math.random(); break;
              case 3: px = cornerDist - Math.random(); pz = cornerDist - Math.random(); break;
              // Edges
              case 4: px = (Math.random() - 0.5) * ROOM_SIZE * 0.8; pz = -cornerDist + Math.random() * 0.5; break;
              case 5: px = (Math.random() - 0.5) * ROOM_SIZE * 0.8; pz = cornerDist - Math.random() * 0.5; break;
              case 6: px = -cornerDist + Math.random() * 0.5; pz = (Math.random() - 0.5) * ROOM_SIZE * 0.8; break;
              case 7: px = cornerDist - Math.random() * 0.5; pz = (Math.random() - 0.5) * ROOM_SIZE * 0.8; break;
            }
            break;
          }
          case 'under_furniture': {
            // Place some legos near furniture leg positions
            if (furnitureLegPositions.length > 0 && Math.random() < 0.5) {
              const legPos = furnitureLegPositions[Math.floor(Math.random() * furnitureLegPositions.length)];
              px = legPos.x + (Math.random() - 0.5) * 1.5;
              pz = legPos.z + (Math.random() - 0.5) * 1.5;
            } else {
              do {
                px = (Math.random() - 0.5) * (ROOM_SIZE - 4);
                pz = (Math.random() - 0.5) * (ROOM_SIZE - 4);
              } while (Math.abs(px - BOX_POS.x) < 2 && Math.abs(pz - BOX_POS.z) < 2);
            }
            break;
          }
          default: { // 'random'
            do {
              px = (Math.random() - 0.5) * (ROOM_SIZE - 4);
              pz = (Math.random() - 0.5) * (ROOM_SIZE - 4);
            } while (Math.abs(px - BOX_POS.x) < 2 && Math.abs(pz - BOX_POS.z) < 2);
            break;
          }
        }

        brick.position.set(px, 0, pz);
        brick.rotation.y = Math.random() * Math.PI * 2;

        if (Math.random() < 0.3) {
          brick.rotation.x = (Math.random() - 0.5) * 0.5;
          brick.rotation.z = (Math.random() - 0.5) * 0.5;
          brick.position.y = 0.1 + Math.random() * 0.2;
        }

        // Stuck lego (FM-C07)
        if (stuckRatio > 0 && Math.random() < stuckRatio) {
          brick.userData.stuck = true;
        }

        scene.add(brick);
        bricks.push(brick);
      }
    }

    // ====== LOADER MODEL ======
    const loaderGroup = new THREE.Group();
    let bucketPivot;
    let bucketAngle = 0;
    let liftHeight = 0;

    function createLoader() {
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFFCC00, roughness: 0.4, metalness: 0.1 });
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.6, 2.4), bodyMat);
      body.position.y = 0.5;
      body.castShadow = true;
      loaderGroup.add(body);

      const cabinMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.2 });
      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.0), cabinMat);
      cabin.position.set(0, 1.05, -0.3);
      cabin.castShadow = true;
      loaderGroup.add(cabin);

      const glassMat = new THREE.MeshStandardMaterial({
        color: 0x88CCFF, roughness: 0.05, metalness: 0.3, transparent: true, opacity: 0.5
      });
      const glass = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.4), glassMat);
      glass.position.set(0, 1.1, 0.21);
      loaderGroup.add(glass);

      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
      const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 12);
      const wheelPositions = [
        [-0.8, 0.25, 0.8], [0.8, 0.25, 0.8],
        [-0.8, 0.25, -0.8], [0.8, 0.25, -0.8]
      ];
      wheelPositions.forEach(([x, y, z]) => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.position.set(x, y, z);
        wheel.rotation.z = Math.PI / 2;
        wheel.castShadow = true;
        loaderGroup.add(wheel);
      });

      const armMat = new THREE.MeshStandardMaterial({ color: 0xDDBB00, roughness: 0.5 });
      [-0.7, 0.7].forEach(x => {
        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 1.5), armMat);
        arm.position.set(x, 0.7, 1.0);
        loaderGroup.add(arm);
      });

      bucketPivot = new THREE.Group();
      bucketPivot.position.set(0, 0.4, 1.7);

      const bucketMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.3 });

      const bucketBottom = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.06, 0.8), bucketMat);
      bucketBottom.position.set(0, 0, 0.4);
      bucketPivot.add(bucketBottom);

      const bucketBack = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.5, 0.06), bucketMat);
      bucketBack.position.set(0, 0.25, 0);
      bucketPivot.add(bucketBack);

      const bucketSideGeo = new THREE.BoxGeometry(0.06, 0.5, 0.8);
      [-0.77, 0.77].forEach(x => {
        const side = new THREE.Mesh(bucketSideGeo, bucketMat);
        side.position.set(x, 0.25, 0.4);
        bucketPivot.add(side);
      });

      const toothMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4 });
      for (let i = 0; i < 5; i++) {
        const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.06), toothMat);
        tooth.position.set(-0.6 + i * 0.3, -0.05, 0.82);
        bucketPivot.add(tooth);
      }

      loaderGroup.add(bucketPivot);

      const exhaust = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.06, 0.4, 8),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5 })
      );
      exhaust.position.set(0.5, 1.1, -0.9);
      loaderGroup.add(exhaust);

      const lightMat = new THREE.MeshStandardMaterial({ color: 0xFFFFCC, emissive: 0xFFFF88, emissiveIntensity: 0.5 });
      [-0.5, 0.5].forEach(x => {
        const headlight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), lightMat);
        headlight.position.set(x, 0.65, 1.22);
        loaderGroup.add(headlight);
      });

      loaderGroup.position.copy(LOADER_START);
      loaderGroup.castShadow = true;
      scene.add(loaderGroup);
    }

    // ====== LOADER STATE ======
    const loader = {
      x: LOADER_START.x,
      z: LOADER_START.z,
      rotation: 0,
      speed: 0,
      maxSpeed: 3.0,
      turnSpeed: 1.8,
      bucketAngle: 0,
      liftHeight: 0,
      carriedBrick: null,
      collected: 0,
    };

    // ====== EXPERT AGENT ======
    const STATES = {
      SCANNING: 'SCANNING',
      APPROACHING: 'APPROACHING',
      LOWERING_BUCKET: 'LOWERING_BUCKET',
      SCOOPING: 'SCOOPING',
      LIFTING: 'LIFTING',
      TRANSPORTING: 'TRANSPORTING',
      DUMPING: 'DUMPING',
      COMPLETE: 'COMPLETE',
    };

    const agent = {
      state: STATES.SCANNING,
      target: null,
      targetBrickIndex: -1,
      stateTimer: 0,
      actions: { steering: 0, throttle: 0, bucket: 0, lift: 0 },
      ghostDelayCounter: 0, // For FM-F02
    };

    // ====== Gaussian noise helper ======
    function gaussianNoise(stddev) {
      // Box-Muller transform
      const u1 = Math.random();
      const u2 = Math.random();
      return stddev * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    }

    function findNearestBrick() {
      let nearest = null;
      let minDist = Infinity;
      let nearestIdx = -1;

      for (let i = 0; i < bricks.length; i++) {
        if (bricks[i].userData.collected) continue;
        let bx = bricks[i].position.x;
        let bz = bricks[i].position.z;

        // Apply sensor noise (FM-F03)
        if (SCENARIO_CONFIG.sensorNoise) {
          bx += gaussianNoise(SCENARIO_CONFIG.sensorNoise.position || 0);
          bz += gaussianNoise(SCENARIO_CONFIG.sensorNoise.position || 0);
        }

        const dx = bx - loader.x;
        const dz = bz - loader.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearest = bricks[i];
          nearestIdx = i;
        }
      }
      return { brick: nearest, dist: minDist, index: nearestIdx };
    }

    function angleDiff(target, current) {
      let diff = target - current;
      while (diff > Math.PI) diff -= 2 * Math.PI;
      while (diff < -Math.PI) diff += 2 * Math.PI;
      return diff;
    }

    function angleToTarget(tx, tz) {
      return Math.atan2(tx - loader.x, tz - loader.z);
    }

    function distToTarget(tx, tz) {
      const dx = tx - loader.x;
      const dz = tz - loader.z;
      return Math.sqrt(dx * dx + dz * dz);
    }

    function updateAgent(dt) {
      agent.stateTimer += dt;
      const a = agent.actions;

      a.steering = 0;
      a.throttle = 0;
      a.bucket = 0;
      a.lift = 0;

      switch (agent.state) {
        case STATES.SCANNING: {
          const result = findNearestBrick();
          if (!result.brick) {
            agent.state = STATES.COMPLETE;
            break;
          }
          agent.target = result.brick;
          agent.targetBrickIndex = result.index;
          agent.state = STATES.APPROACHING;
          agent.stateTimer = 0;

          a.bucket = -loader.bucketAngle * 2;
          break;
        }

        case STATES.APPROACHING: {
          if (!agent.target || agent.target.userData.collected) {
            agent.state = STATES.SCANNING;
            break;
          }

          const targetAngle = angleToTarget(agent.target.position.x, agent.target.position.z);
          const aDiff = angleDiff(targetAngle, loader.rotation);
          const dist = distToTarget(agent.target.position.x, agent.target.position.z);

          a.steering = Math.max(-1, Math.min(1, aDiff / 1.0));

          if (Math.abs(aDiff) > 0.8) {
            a.throttle = 0.2;
          } else {
            a.throttle = Math.min(1.0, dist / 3.0);
            a.throttle = Math.max(0.3, a.throttle);
          }

          if (dist < 1.5) {
            agent.state = STATES.LOWERING_BUCKET;
            agent.stateTimer = 0;
          }
          break;
        }

        case STATES.LOWERING_BUCKET: {
          a.bucket = -1;
          a.throttle = 0.15;

          if (agent.target && !agent.target.userData.collected) {
            const targetAngle = angleToTarget(agent.target.position.x, agent.target.position.z);
            const aDiff = angleDiff(targetAngle, loader.rotation);
            a.steering = Math.max(-1, Math.min(1, aDiff / 0.8));
          }

          if (loader.bucketAngle <= -0.5) {
            agent.state = STATES.SCOOPING;
            agent.stateTimer = 0;
          }
          break;
        }

        case STATES.SCOOPING: {
          a.throttle = 0.4;
          a.bucket = 0;

          if (agent.target && !agent.target.userData.collected) {
            const targetAngle = angleToTarget(agent.target.position.x, agent.target.position.z);
            const aDiff = angleDiff(targetAngle, loader.rotation);
            a.steering = Math.max(-1, Math.min(1, aDiff / 0.6));
          }

          const dist = agent.target ? distToTarget(agent.target.position.x, agent.target.position.z) : 999;

          // Stuck lego requires extra time (FM-C07)
          const isStuck = agent.target && agent.target.userData.stuck;
          const extraTime = isStuck ? (SCENARIO_CONFIG.stuckScoopExtraTime || 1.5) : 0;
          const scoopTimeout = 2.0 + extraTime;

          if (dist < 0.8 || agent.stateTimer > scoopTimeout) {
            // Ghost target delay (FM-F02)
            if (SCENARIO_CONFIG.ghostTargetDelay && agent.ghostDelayCounter < SCENARIO_CONFIG.ghostTargetDelay) {
              agent.ghostDelayCounter++;
              break; // Delay setting collected flag by N frames
            }
            agent.ghostDelayCounter = 0;

            if (agent.target && !agent.target.userData.collected) {
              agent.target.userData.collected = true;
              loader.carriedBrick = agent.target;

              scene.remove(agent.target);
              agent.target.position.set(0, 0.1, 0.4);
              agent.target.rotation.set(0, 0, 0);
              agent.target.scale.set(0.5, 0.5, 0.5);
              bucketPivot.add(agent.target);
            }
            agent.state = STATES.LIFTING;
            agent.stateTimer = 0;
          }
          break;
        }

        case STATES.LIFTING: {
          a.bucket = 1;
          a.lift = 1;
          a.throttle = 0;

          if (loader.bucketAngle >= 0.2 && agent.stateTimer > 0.5) {
            agent.state = STATES.TRANSPORTING;
            agent.stateTimer = 0;
          }
          break;
        }

        case STATES.TRANSPORTING: {
          const targetAngle = angleToTarget(BOX_POS.x, BOX_POS.z);
          const aDiff = angleDiff(targetAngle, loader.rotation);
          const dist = distToTarget(BOX_POS.x, BOX_POS.z);

          a.steering = Math.max(-1, Math.min(1, aDiff / 1.0));

          if (Math.abs(aDiff) > 0.8) {
            a.throttle = 0.25;
          } else {
            a.throttle = Math.min(1.0, dist / 3.0);
            a.throttle = Math.max(0.3, a.throttle);
          }

          a.bucket = 0;
          a.lift = 0;

          if (dist < 2.0) {
            agent.state = STATES.DUMPING;
            agent.stateTimer = 0;
          }
          break;
        }

        case STATES.DUMPING: {
          a.throttle = 0;
          a.bucket = 1;
          a.lift = -1;

          if (agent.stateTimer > 0.8) {
            if (loader.carriedBrick) {
              bucketPivot.remove(loader.carriedBrick);
              addToBoxPile(loader.carriedBrick.userData.color);
              loader.carriedBrick = null;
              loader.collected++;
            }

            agent.state = STATES.SCANNING;
            agent.stateTimer = 0;
          }
          break;
        }

        case STATES.COMPLETE: {
          a.throttle = 0;
          a.steering = 0;
          break;
        }
      }

      return a;
    }

    // ====== BOX PILE ======
    const boxPileMeshes = [];

    function addToBoxPile(color) {
      const size = 0.12 + Math.random() * 0.08;
      const mini = new THREE.Mesh(
        new THREE.BoxGeometry(size, size * 0.6, size * 0.5),
        new THREE.MeshStandardMaterial({ color, roughness: 0.3 })
      );
      const pileH = 0.15 + boxPileMeshes.length * 0.04;
      mini.position.set(
        BOX_POS.x + (Math.random() - 0.5) * 1.5,
        Math.min(pileH, 1.5),
        BOX_POS.z + (Math.random() - 0.5) * 1.2
      );
      mini.rotation.set(Math.random() * 0.5, Math.random() * Math.PI, Math.random() * 0.5);
      mini.castShadow = true;
      scene.add(mini);
      boxPileMeshes.push(mini);
    }

    // ====== PHYSICS UPDATE ======
    function updateLoader(dt, actions) {
      const turnAmount = actions.steering * loader.turnSpeed * dt;
      loader.rotation += turnAmount;

      const speed = actions.throttle * loader.maxSpeed;
      loader.x += Math.sin(loader.rotation) * speed * dt;
      loader.z += Math.cos(loader.rotation) * speed * dt;

      const halfRoom = ROOM_SIZE / 2;
      const bound = halfRoom - 0.5;
      loader.x = Math.max(-bound, Math.min(bound, loader.x));
      loader.z = Math.max(-bound, Math.min(bound, loader.z));

      const bucketSpeed = 1.5;
      loader.bucketAngle += actions.bucket * bucketSpeed * dt;
      loader.bucketAngle = Math.max(-0.7, Math.min(0.5, loader.bucketAngle));

      const liftSpeed = 1.0;
      loader.liftHeight += actions.lift * liftSpeed * dt;
      loader.liftHeight = Math.max(0, Math.min(1, loader.liftHeight));

      loaderGroup.position.set(loader.x, 0, loader.z);
      loaderGroup.rotation.y = loader.rotation;

      if (bucketPivot) {
        bucketPivot.rotation.x = loader.bucketAngle;
        bucketPivot.position.y = 0.4 + loader.liftHeight * 0.5;
      }
    }

    // ====== CAMERA UPDATE ======
    const camState = {
      followX: LOADER_START.x + 6,
      followY: 8,
      followZ: LOADER_START.z + 8,
      lookX: LOADER_START.x,
      lookZ: LOADER_START.z,
    };

    function updateCameras(dt) {
      const behindDist = 7;
      const behindHeight = 5;
      const targetCamX = loader.x - Math.sin(loader.rotation) * behindDist;
      const targetCamZ = loader.z - Math.cos(loader.rotation) * behindDist;

      const lerpFactor = 1 - Math.pow(0.02, dt);
      camState.followX += (targetCamX - camState.followX) * lerpFactor;
      camState.followY += (behindHeight - camState.followY) * lerpFactor;
      camState.followZ += (targetCamZ - camState.followZ) * lerpFactor;
      camState.lookX += (loader.x - camState.lookX) * lerpFactor * 1.5;
      camState.lookZ += (loader.z - camState.lookZ) * lerpFactor * 1.5;

      followCam.position.set(camState.followX, camState.followY, camState.followZ);
      followCam.up.set(0, 1, 0);
      followCam.lookAt(camState.lookX, 0.5, camState.lookZ);

      const egoX = loader.x + Math.sin(loader.rotation) * 0.5;
      const egoZ = loader.z + Math.cos(loader.rotation) * 0.5;
      egoCam.position.set(egoX, 1.3, egoZ);
      egoCam.up.set(0, 1, 0);
      const lookAheadX = loader.x + Math.sin(loader.rotation) * 5;
      const lookAheadZ = loader.z + Math.cos(loader.rotation) * 5;
      egoCam.lookAt(lookAheadX, 0.3, lookAheadZ);

      birdCam.position.set(loader.x, 14, loader.z);
      birdCam.up.set(0, 0, -1);
      birdCam.lookAt(loader.x, 0, loader.z);

      const sideOffsetX = Math.cos(loader.rotation) * 6;
      const sideOffsetZ = -Math.sin(loader.rotation) * 6;
      sideCam.position.set(loader.x + sideOffsetX, 3, loader.z + sideOffsetZ);
      sideCam.up.set(0, 1, 0);
      sideCam.lookAt(loader.x, 0.5, loader.z);

      const aheadX = loader.x + Math.sin(loader.rotation) * 5;
      const aheadZ = loader.z + Math.cos(loader.rotation) * 5;
      frontCam.position.set(aheadX, 2.5, aheadZ);
      frontCam.up.set(0, 1, 0);
      frontCam.lookAt(loader.x, 0.3, loader.z);
    }

    // ====== DATA RECORDING ======
    const actionLog = [];
    let frameCount = 0;

    function recordFrame(actions) {
      actionLog.push({
        frame: frameCount,
        time: frameCount * SIM_DT,
        state: agent.state,
        scenario: SCENARIO_CONFIG.id,
        loader: {
          x: +loader.x.toFixed(3),
          z: +loader.z.toFixed(3),
          rotation: +loader.rotation.toFixed(4),
          bucketAngle: +loader.bucketAngle.toFixed(3),
          liftHeight: +loader.liftHeight.toFixed(3),
        },
        actions: {
          steering: +actions.steering.toFixed(4),
          throttle: +actions.throttle.toFixed(4),
          bucket: +actions.bucket.toFixed(4),
          lift: +actions.lift.toFixed(4),
        },
        remaining: bricks.filter(b => !b.userData.collected).length,
        collected: loader.collected,
      });
    }

    // ====== VIDEO RECORDING ======
    let mediaRecorder = null;
    let recordedChunks = [];

    function startRecording() {
      const stream = renderer.domElement.captureStream(30);
      mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9',
        videoBitsPerSecond: 5000000,
      });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);

        // Determine filename
        const filename = (autoRecord && scenarioId)
          ? `${scenarioId}.webm`
          : `loader-cleanup-${Date.now()}.webm`;

        const downloadBtn = document.getElementById('download-btn');
        downloadBtn.style.display = 'block';
        downloadBtn.onclick = () => {
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
        };

        // Auto-download
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();

        // Notify parent iframe if autoRecord
        if (autoRecord && scenarioId) {
          try {
            window.parent.postMessage({ type: 'scenarioComplete', id: scenarioId }, '*');
          } catch (e) {
            // Ignore cross-origin errors
          }
        }
      };

      mediaRecorder.start();
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }

    // ====== HUD UPDATE ======
    function updateHUD(actions) {
      document.getElementById('agent-state').textContent = agent.state;
      document.getElementById('legos-remaining').textContent = bricks.filter(b => !b.userData.collected).length;
      document.getElementById('legos-collected').textContent = loader.collected;
      document.getElementById('frame-count').textContent = frameCount;

      if (actions) {
        document.getElementById('action-display').innerHTML =
          `steering: ${actions.steering.toFixed(2)}<br>` +
          `throttle: ${actions.throttle.toFixed(2)}<br>` +
          `bucket: ${actions.bucket.toFixed(2)}<br>` +
          `lift: ${actions.lift.toFixed(2)}`;
      }
    }

    // ====== PARTICLES ======
    const particles = [];

    function spawnParticles(position, color, count = 8) {
      const mat = new THREE.MeshBasicMaterial({ color });
      for (let i = 0; i < count; i++) {
        const size = 0.03 + Math.random() * 0.06;
        const p = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), mat.clone());
        p.position.copy(position);
        const angle = Math.random() * Math.PI * 2;
        p.userData.vel = new THREE.Vector3(
          Math.cos(angle) * (2 + Math.random() * 3),
          3 + Math.random() * 4,
          Math.sin(angle) * (2 + Math.random() * 3)
        );
        p.userData.life = 0.5 + Math.random() * 0.3;
        p.userData.age = 0;
        scene.add(p);
        particles.push(p);
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.userData.age += dt;
        if (p.userData.age >= p.userData.life) {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
          particles.splice(i, 1);
          continue;
        }
        p.userData.vel.y -= 12 * dt;
        p.position.addScaledVector(p.userData.vel, dt);
        p.rotation.x += dt * 5;
        const fade = 1 - p.userData.age / p.userData.life;
        p.material.opacity = fade;
        p.material.transparent = true;
        p.scale.setScalar(fade);
      }
    }

    // ====== DUST MOTES ======
    const dustMotes = [];
    function createDustMotes() {
      const dustMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
      const dustGeo = new THREE.SphereGeometry(0.02, 4, 4);
      for (let i = 0; i < 40; i++) {
        const m = new THREE.Mesh(dustGeo, dustMat.clone());
        m.position.set(
          (Math.random() - 0.5) * 14,
          0.5 + Math.random() * 5,
          (Math.random() - 0.5) * 14
        );
        m.userData.baseY = m.position.y;
        m.userData.phase = Math.random() * Math.PI * 2;
        m.userData.speed = 0.2 + Math.random() * 0.3;
        scene.add(m);
        dustMotes.push(m);
      }
    }

    function updateDustMotes(time) {
      dustMotes.forEach(m => {
        m.position.y = m.userData.baseY + Math.sin(time * m.userData.speed + m.userData.phase) * 0.3;
      });
    }

    // ====== LIGHTING TRANSITION (FM-E01) ======
    let lightingTransitionState = null;

    function initLightingTransition() {
      const lt = SCENARIO_CONFIG.dynamic && SCENARIO_CONFIG.dynamic.lightingTransition;
      if (!lt) return;

      // Estimate total time: ~(LEGO_COUNT * 5) seconds for all legos
      const estimatedTotalTime = LEGO_COUNT * 5;
      const triggerTime = estimatedTotalTime * (lt.atProgress || 0.5);

      lightingTransitionState = {
        triggerTime,
        durationSec: lt.durationSec || 8,
        fromAmbient: lt.fromAmbient,
        fromDirectional: lt.fromDirectional,
        toAmbient: lt.toAmbient,
        toDirectional: lt.toDirectional,
        started: false,
        startTime: 0,
        complete: false,
      };
    }

    function updateLightingTransition(simTime) {
      if (!lightingTransitionState || lightingTransitionState.complete) return;

      if (!lightingTransitionState.started && simTime >= lightingTransitionState.triggerTime) {
        lightingTransitionState.started = true;
        lightingTransitionState.startTime = simTime;
      }

      if (lightingTransitionState.started) {
        const elapsed = simTime - lightingTransitionState.startTime;
        const t = Math.min(1, elapsed / lightingTransitionState.durationSec);

        // Lerp ambient and directional
        ambientLight.intensity = lightingTransitionState.fromAmbient +
          (lightingTransitionState.toAmbient - lightingTransitionState.fromAmbient) * t;
        sunLight.intensity = lightingTransitionState.fromDirectional +
          (lightingTransitionState.toDirectional - lightingTransitionState.fromDirectional) * t;

        if (t >= 1) {
          lightingTransitionState.complete = true;
        }
      }
    }

    // ====== BUCKET VIBRATION (FM-F01) ======
    function applyBucketVibration(simTime) {
      if (!SCENARIO_CONFIG.bucketVibration || !bucketPivot) return;

      const amp = SCENARIO_CONFIG.bucketVibration.amplitude || 0.03;
      const freq = SCENARIO_CONFIG.bucketVibration.frequency || 8;
      const noise = Math.sin(simTime * freq * Math.PI * 2) * amp;
      bucketPivot.rotation.x += noise;
    }

    // ====== INIT ======
    createRoom();
    createExtraFurniture(SCENARIO_CONFIG.furniture.extras);
    createObstacles(SCENARIO_CONFIG.obstacles);
    createDistractors(SCENARIO_CONFIG.distractors);
    createForbiddenObjects(SCENARIO_CONFIG.forbiddenObjects);
    scatterBricks(LEGO_COUNT);
    createLoader();
    createDustMotes();
    initLightingTransition();

    // Init cameras at loader position
    camState.followX = LOADER_START.x + 6;
    camState.followZ = LOADER_START.z + 8;
    camState.lookX = LOADER_START.x;
    camState.lookZ = LOADER_START.z;

    // ====== MAIN LOOP ======
    let simTime = 0;
    let running = true;
    let started = false;

    function animate() {
      if (!running) return;
      requestAnimationFrame(animate);

      const dt = SIM_DT;
      simTime += dt;
      frameCount++;

      // Start recording on first frame
      if (!started) {
        started = true;
        startRecording();
      }

      // Update agent
      const actions = updateAgent(dt);

      // Update physics
      updateLoader(dt, actions);

      // Bucket vibration (FM-F01) - applied after normal physics
      applyBucketVibration(simTime);

      // Lighting transition (FM-E01)
      updateLightingTransition(simTime);

      // Update cameras
      updateCameras(dt);

      // Record data
      recordFrame(actions);

      // Particles
      updateParticles(dt);
      updateDustMotes(simTime);

      // Check for brick collection particles
      if (agent.state === STATES.SCOOPING && agent.target && !agent.target.userData.collected) {
        const dist = distToTarget(agent.target.position.x, agent.target.position.z);
        if (dist < 0.8) {
          spawnParticles(agent.target.position, agent.target.userData.color);
        }
      }

      // Render main (follow) view
      renderer.render(scene, followCam);

      // Render mini views (4 sub-cameras)
      egoRenderer.render(scene, egoCam);
      birdRenderer.render(scene, birdCam);
      sideRenderer.render(scene, sideCam);
      frontRenderer.render(scene, frontCam);

      // Update HUD
      updateHUD(actions);

      // Check completion
      if (agent.state === STATES.COMPLETE) {
        setTimeout(() => {
          running = false;
          stopRecording();

          // Save action log (skip in autoRecord mode to avoid download spam)
          if (!autoRecord) {
            const logBlob = new Blob([JSON.stringify(actionLog, null, 2)], { type: 'application/json' });
            const logUrl = URL.createObjectURL(logBlob);
            const logLink = document.createElement('a');
            logLink.href = logUrl;
            logLink.download = `actions-${Date.now()}.jsonl`;
            logLink.click();
          }

          // Show complete screen (skip in autoRecord mode)
          if (!autoRecord) {
            const totalTime = (frameCount * SIM_DT).toFixed(1);
            document.getElementById('complete-stats').innerHTML =
              `Scenario: ${SCENARIO_CONFIG.id} - ${SCENARIO_CONFIG.nameEn || SCENARIO_CONFIG.name}<br>` +
              `Collected: ${loader.collected} / ${LEGO_COUNT} legos<br>` +
              `Time: ${totalTime}s (${frameCount} frames)<br>` +
              `Cameras: 5 (follow, ego, bird_eye, side, front)<br>` +
              `Action log saved (${actionLog.length} entries)`;
            document.getElementById('complete-screen').style.display = 'flex';
          }
          document.getElementById('recording-indicator').style.display = 'none';
        }, 1000);
      }
    }

    // Handle resize
    window.addEventListener('resize', () => {
      followCam.aspect = window.innerWidth / window.innerHeight;
      followCam.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    animate();
  </script>
</body>
</html>
